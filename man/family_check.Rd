% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/family_check.R
\docType{methods}
\name{family_check}
\alias{family_check}
\alias{family_check,character-method}
\alias{family_check,character}
\alias{family_check,Pedigree-method}
\alias{family_check,Pedigree}
\title{Check family}
\usage{
family_check(obj, ...)

\S4method{family_check}{character}(obj, dadid, momid, famid, newfam)

\S4method{family_check}{Pedigree}(obj)
}
\arguments{
\item{obj}{A pedigree object or a vector of the individuals identifiers}

\item{dadid}{A vector of the father identifiers}

\item{momid}{A vector of the mother identifiers}

\item{famid}{A vector of family identifiers}

\item{newfam}{The result of a call to \code{make_famid()}. If this has already
been computed by the user, adding it as an argument shortens the running
time somewhat.}
}
\value{
a data frame with one row for each unique family id in the
\code{famid} argument or the one detected in the pedigree object.
Components of the output are:
\itemize{
\item famid The family id, as entered into the data set
\item n Number of subjects in the family
\item unrelated Number of them that appear to be unrelated to
anyone else in the entire pedigree set.  This is usually marry-ins with no
children (in the pedigree), and if so are not a problem.
\item split Number of unique 'new' family ids.
\itemize{
\item 0 = no one in this 'family' is related to anyone else (not good)
\item 1 = everythings is fine
\item 2+ = the family appears to be a set of disjoint trees.
Are you missing some of the people?
}
\item join Number of other families that had a unique
famid, but are actually joined to this one.  0 is the hope.
}
}
\description{
Error check for a family classification
}
\details{
Given a family id vector, also compute the familial grouping from first
principles using the parenting data, and compare the results.

The \code{make_famid} function is used to create a de novo family id from the
parentage data, and this is compared to the family id given in the data.

If there are any joins, then an attribute 'join' is attached.
It will be a matrix with famid as row labels, new-family-id as the columns,
and the number of subjects as entries.
}
\examples{

# use 2 samplepeds
data(sampleped)
pedAll <- pedigree(sampleped)

## check them giving separate ped ids
fcheck.sep <- family_check(pedAll)
fcheck.sep

## check assigning them same ped id
fcheck.combined <- with(sampleped, family_check(id, dadid, momid,
rep(1, nrow(sampleped))))
fcheck.combined

# make person 120's father be her son.
sampleped[20, 3] <- 131
fcheck1.bad <- try(
  {
    with(sampleped, family_check(id, father, mother, family))
  },
  silent = FALSE
)

## fcheck1.bad is a try-error

}
\seealso{
\code{\link[=make_famid]{make_famid()}}, \code{\link[=kinship]{kinship()}}
}
\keyword{internal}
